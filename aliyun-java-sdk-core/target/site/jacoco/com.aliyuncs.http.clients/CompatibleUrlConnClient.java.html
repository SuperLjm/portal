<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompatibleUrlConnClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">aliyun-java-sdk-core</a> &gt; <a href="index.source.html" class="el_package">com.aliyuncs.http.clients</a> &gt; <span class="el_source">CompatibleUrlConnClient.java</span></div><h1>CompatibleUrlConnClient.java</h1><pre class="source lang-java linenums">package com.aliyuncs.http.clients;

import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.http.*;
import com.aliyuncs.utils.EnvironmentUtils;
import org.apache.http.conn.ssl.DefaultHostnameVerifier;
import org.apache.http.conn.ssl.NoopHostnameVerifier;

import javax.net.ssl.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.Proxy;
import java.net.URL;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Future;

public class CompatibleUrlConnClient extends IHttpClient {

    protected static final String CONTENT_TYPE = &quot;Content-Type&quot;;
    protected static final String ACCEPT_ENCODING = &quot;Accept-Encoding&quot;;

    public CompatibleUrlConnClient(HttpClientConfig clientConfig) throws ClientException {
<span class="fc" id="L33">        super(clientConfig);</span>
<span class="fc" id="L34">    }</span>

    public static HttpResponse compatibleGetResponse(HttpRequest request) throws IOException, ClientException {
<span class="fc" id="L37">        CompatibleUrlConnClient client = new CompatibleUrlConnClient(null);</span>
<span class="fc" id="L38">        HttpResponse response = client.syncInvoke(request);</span>
<span class="fc" id="L39">        client.close();</span>
<span class="fc" id="L40">        return response;</span>
    }

    @Override
    protected void init(HttpClientConfig clientConfig) {
        // do nothing
<span class="fc" id="L46">    }</span>

    @Override
    public HttpResponse syncInvoke(HttpRequest request) throws IOException, ClientException {
<span class="fc" id="L50">        InputStream content = null;</span>
<span class="fc" id="L51">        HttpResponse response = null;</span>
<span class="fc" id="L52">        HttpURLConnection httpConn = buildHttpConnection(request);</span>
<span class="fc" id="L53">        OutputStream out = null;</span>

        try {
<span class="fc" id="L56">            httpConn.connect();</span>
<span class="fc bfc" id="L57" title="All 4 branches covered.">            if (null != request.getHttpContent() &amp;&amp; request.getHttpContent().length &gt; 0) {</span>
<span class="fc" id="L58">                out = httpConn.getOutputStream();</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">                if (request.getSysMethod().hasContent()) {</span>
<span class="fc" id="L60">                    out.write(request.getHttpContent());</span>
                }
<span class="fc" id="L62">                out.flush();</span>

            }

<span class="fc" id="L66">            content = httpConn.getInputStream();</span>
<span class="fc" id="L67">            response = new HttpResponse(httpConn.getURL().toString());</span>
<span class="fc" id="L68">            parseHttpConn(response, httpConn, content);</span>
<span class="fc" id="L69">            return response;</span>
<span class="fc" id="L70">        } catch (IOException e) {</span>
<span class="fc" id="L71">            content = httpConn.getErrorStream();</span>
<span class="fc" id="L72">            response = new HttpResponse(httpConn.getURL().toString());</span>
<span class="fc" id="L73">            parseHttpConn(response, httpConn, content);</span>
<span class="fc" id="L74">            return response;</span>
        } finally {
<span class="fc bfc" id="L76" title="All 2 branches covered.">            if (content != null) {</span>
<span class="fc" id="L77">                content.close();</span>
            }
<span class="fc" id="L79">            httpConn.disconnect();</span>
        }
    }

    @Override
    public Future&lt;HttpResponse&gt; asyncInvoke(HttpRequest apiRequest, CallBack callback) {
<span class="fc" id="L85">        throw new IllegalStateException(&quot;not supported&quot;);</span>
    }

    private boolean calcIgnoreSSLCert(HttpRequest request) {
<span class="fc bfc" id="L89" title="All 2 branches covered.">        boolean ignoreSSLCert = request.isIgnoreSSLCerts() ? request.isIgnoreSSLCerts() : clientConfig.isIgnoreSSLCerts();</span>
<span class="fc" id="L90">        return ignoreSSLCert;</span>
    }

    private CompositeX509TrustManager calcX509TrustManager(HttpRequest request) throws KeyStoreException, NoSuchAlgorithmException {
<span class="fc" id="L94">        X509TrustManager[] trustManagers = null;</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (clientConfig.getX509TrustManagers() != null) {</span>
<span class="fc" id="L97">            trustManagers = clientConfig.getX509TrustManagers();</span>
        }
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (request.getX509TrustManagers() != null) {</span>
<span class="fc" id="L100">            trustManagers = request.getX509TrustManagers();</span>
        }

<span class="fc" id="L103">        List&lt;TrustManager&gt; trustManagerList = new ArrayList&lt;TrustManager&gt;();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (null != trustManagers) {</span>
<span class="fc" id="L105">            trustManagerList.addAll(Arrays.asList(trustManagers));</span>
        }

        // get trustManager using default certification from jdk
<span class="fc" id="L109">        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L110">        tmf.init((KeyStore) null);</span>
<span class="fc" id="L111">        trustManagerList.addAll(Arrays.asList(tmf.getTrustManagers()));</span>

<span class="fc" id="L113">        final List&lt;X509TrustManager&gt; finalTrustManagerList = new ArrayList&lt;X509TrustManager&gt;();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (TrustManager tm : trustManagerList) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (tm instanceof X509TrustManager) {</span>
<span class="fc" id="L116">                finalTrustManagerList.add((X509TrustManager) tm);</span>
            }
<span class="fc" id="L118">        }</span>
<span class="fc" id="L119">        CompositeX509TrustManager compositeX509TrustManager = new CompositeX509TrustManager(finalTrustManagerList);</span>
<span class="fc" id="L120">        compositeX509TrustManager.setIgnoreSSLCert(calcIgnoreSSLCert(request));</span>
<span class="fc" id="L121">        return compositeX509TrustManager;</span>
    }

    private KeyManager[] calcKeyManager(HttpRequest request) {
<span class="fc" id="L125">        KeyManager[] keyManagers = null;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (clientConfig.getKeyManagers() != null) {</span>
<span class="fc" id="L127">            keyManagers = clientConfig.getKeyManagers();</span>
        }
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (request.getKeyManagers() != null) {</span>
<span class="fc" id="L130">            keyManagers = request.getKeyManagers();</span>
        }
<span class="fc" id="L132">        return keyManagers;</span>
    }


    private SSLSocketFactory createSSLSocketFactory(HttpRequest request) throws ClientException {
        try {
<span class="fc" id="L138">            CompositeX509TrustManager compositeX509TrustManager = calcX509TrustManager(request);</span>
<span class="fc" id="L139">            KeyManager[] keyManagers = calcKeyManager(request);</span>
<span class="fc" id="L140">            SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="fc" id="L141">            sslContext.init(keyManagers, new TrustManager[]{compositeX509TrustManager}, clientConfig.getSecureRandom());</span>
<span class="fc" id="L142">            return sslContext.getSocketFactory();</span>
<span class="nc" id="L143">        } catch (Exception e) {</span>
<span class="nc" id="L144">            throw new ClientException(&quot;SDK.InitFailed&quot;, &quot;Init https with SSL socket failed&quot;, e);</span>
        }

    }

    private HostnameVerifier createHostnameVerifier(HttpRequest request) {
<span class="fc bfc" id="L150" title="All 2 branches covered.">        boolean ignoreSSLCert = request.isIgnoreSSLCerts() ? request.isIgnoreSSLCerts() : clientConfig.isIgnoreSSLCerts();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (ignoreSSLCert) {</span>
<span class="fc" id="L152">            return new NoopHostnameVerifier();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        } else if (clientConfig.getHostnameVerifier() != null) {</span>
<span class="fc" id="L154">            return clientConfig.getHostnameVerifier();</span>
        } else {
<span class="fc" id="L156">            return new DefaultHostnameVerifier();</span>
        }
    }

    private void checkHttpRequest(HttpRequest request) {
<span class="fc" id="L161">        String strUrl = request.getSysUrl();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (null == strUrl) {</span>
<span class="fc" id="L163">            throw new IllegalArgumentException(&quot;URL is null for HttpRequest.&quot;);</span>
        }
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (null == request.getSysMethod()) {</span>
<span class="fc" id="L166">            throw new IllegalArgumentException(&quot;Method is not set for HttpRequest.&quot;);</span>
        }
<span class="fc" id="L168">    }</span>


    private Proxy calcProxy(URL url, HttpRequest request) throws ClientException {
<span class="fc" id="L172">        String targetHost = url.getHost();</span>
<span class="fc" id="L173">        boolean needProxy = HttpUtil.needProxy(targetHost, clientConfig.getNoProxy(), EnvironmentUtils.getNoProxy());</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (!needProxy) {</span>
<span class="fc" id="L175">            return Proxy.NO_PROXY;</span>
        }
        Proxy proxy;
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (&quot;https&quot;.equalsIgnoreCase(url.getProtocol())) {</span>
<span class="fc" id="L179">            String httpsProxy = EnvironmentUtils.getHttpsProxy();</span>
<span class="fc" id="L180">            proxy = HttpUtil.getJDKProxy(clientConfig.getHttpsProxy(), httpsProxy, request);</span>
<span class="fc" id="L181">        } else {</span>
<span class="fc" id="L182">            String httpProxy = EnvironmentUtils.getHttpProxy();</span>
<span class="fc" id="L183">            proxy = HttpUtil.getJDKProxy(clientConfig.getHttpProxy(), httpProxy, request);</span>
        }
<span class="fc" id="L185">        return proxy;</span>

    }

    private HttpURLConnection initHttpConnection(URL url, HttpRequest request) throws ClientException, IOException {
<span class="fc" id="L190">        HttpURLConnection httpConn = null;</span>
<span class="fc" id="L191">        Proxy proxy = calcProxy(url, request);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (&quot;https&quot;.equalsIgnoreCase(url.getProtocol())) {</span>
<span class="fc" id="L193">            SSLSocketFactory sslSocketFactory = createSSLSocketFactory(request);</span>
<span class="fc" id="L194">            HttpsURLConnection httpsConn = (HttpsURLConnection) url.openConnection(proxy);</span>
<span class="fc" id="L195">            httpsConn.setSSLSocketFactory(sslSocketFactory);</span>
<span class="fc" id="L196">            HostnameVerifier hostnameVerifier = createHostnameVerifier(request);</span>
<span class="fc" id="L197">            httpsConn.setHostnameVerifier(hostnameVerifier);</span>
<span class="fc" id="L198">            httpConn = httpsConn;</span>
        }

<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (httpConn == null) {</span>
<span class="fc" id="L202">            httpConn = (HttpURLConnection) url.openConnection(proxy);</span>
        }

<span class="fc" id="L205">        httpConn.setRequestMethod(request.getSysMethod().toString());</span>
<span class="fc" id="L206">        httpConn.setInstanceFollowRedirects(false);</span>
<span class="fc" id="L207">        httpConn.setDoOutput(true);</span>
<span class="fc" id="L208">        httpConn.setDoInput(true);</span>
<span class="fc" id="L209">        httpConn.setUseCaches(false);</span>
<span class="fc" id="L210">        setConnectionTimeout(httpConn, request);</span>
<span class="fc" id="L211">        setConnectionRequestProperty(httpConn, request);</span>
<span class="fc" id="L212">        return httpConn;</span>
    }

    private void setConnectionTimeout(HttpURLConnection httpConn, HttpRequest request) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (request.getSysConnectTimeout() != null) {</span>
<span class="fc" id="L217">            httpConn.setConnectTimeout(request.getSysConnectTimeout());</span>
        } else {
<span class="fc" id="L219">            httpConn.setConnectTimeout((int) clientConfig.getConnectionTimeoutMillis());</span>
        }

<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (request.getSysReadTimeout() != null) {</span>
<span class="fc" id="L223">            httpConn.setReadTimeout(request.getSysReadTimeout());</span>
        } else {
<span class="fc" id="L225">            httpConn.setReadTimeout((int) clientConfig.getReadTimeoutMillis());</span>
        }
<span class="fc" id="L227">    }</span>

    private void setConnectionRequestProperty(HttpURLConnection httpConn, HttpRequest request) {
<span class="fc" id="L230">        Map&lt;String, String&gt; mappedHeaders = request.getSysHeaders();</span>
<span class="fc" id="L231">        httpConn.setRequestProperty(ACCEPT_ENCODING, &quot;identity&quot;);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for (Entry&lt;String, String&gt; entry : mappedHeaders.entrySet()) {</span>
<span class="fc" id="L233">            httpConn.setRequestProperty(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L234">        }</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (null != request.getHeaderValue(CONTENT_TYPE)) {</span>
<span class="fc" id="L237">            httpConn.setRequestProperty(CONTENT_TYPE, request.getHeaderValue(CONTENT_TYPE));</span>
        } else {
<span class="fc" id="L239">            String contentTypeValue = request.getContentTypeValue(request.getHttpContentType(), request</span>
<span class="fc" id="L240">                    .getSysEncoding());</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (null != contentTypeValue) {</span>
<span class="nc" id="L242">                httpConn.setRequestProperty(CONTENT_TYPE, contentTypeValue);</span>
            }
        }
<span class="fc" id="L245">    }</span>

    private HttpURLConnection buildHttpConnection(HttpRequest request) throws IOException, ClientException {
<span class="fc" id="L248">        checkHttpRequest(request);</span>
<span class="fc" id="L249">        String strUrl = request.getSysUrl();</span>
<span class="fc" id="L250">        URL url = null;</span>
<span class="fc" id="L251">        String[] urlArray = null;</span>
<span class="fc bfc" id="L252" title="All 4 branches covered.">        if (MethodType.POST.equals(request.getSysMethod()) &amp;&amp; null == request.getHttpContent()) {</span>
<span class="fc" id="L253">            urlArray = strUrl.split(&quot;\\?&quot;);</span>
<span class="fc" id="L254">            url = new URL(urlArray[0]);</span>
        } else {
<span class="fc" id="L256">            url = new URL(strUrl);</span>
        }
<span class="fc" id="L258">        System.setProperty(&quot;sun.net.http.allowRestrictedHeaders&quot;, &quot;true&quot;);</span>
<span class="fc" id="L259">        HttpURLConnection httpConn = initHttpConnection(url, request);</span>
<span class="pc bpc" id="L260" title="1 of 6 branches missed.">        if (MethodType.POST.equals(request.getSysMethod()) &amp;&amp; null != urlArray &amp;&amp; urlArray.length == 2) {</span>
<span class="nc" id="L261">            httpConn.getOutputStream().write(urlArray[1].getBytes());</span>
        }
<span class="fc" id="L263">        return httpConn;</span>
    }

    private void parseHttpConn(HttpResponse response, HttpURLConnection httpConn, InputStream content)
            throws IOException {
<span class="fc" id="L268">        byte[] buff = readContent(content);</span>
<span class="fc" id="L269">        response.setStatus(httpConn.getResponseCode());</span>
<span class="fc" id="L270">        response.setReasonPhrase(httpConn.getResponseMessage());</span>
<span class="fc" id="L271">        Map&lt;String, List&lt;String&gt;&gt; headers = httpConn.getHeaderFields();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (Entry&lt;String, List&lt;String&gt;&gt; entry : headers.entrySet()) {</span>
<span class="fc" id="L273">            String key = entry.getKey();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (null == key) {</span>
<span class="fc" id="L275">                continue;</span>
            }
<span class="fc" id="L277">            List&lt;String&gt; values = entry.getValue();</span>
<span class="fc" id="L278">            StringBuilder builder = new StringBuilder(values.get(0));</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">            for (int i = 1; i &lt; values.size(); i++) {</span>
<span class="fc" id="L280">                builder.append(&quot;,&quot;);</span>
<span class="fc" id="L281">                builder.append(values.get(i));</span>
            }
<span class="fc" id="L283">            response.putHeaderParameter(key, builder.toString());</span>
<span class="fc" id="L284">        }</span>
<span class="fc" id="L285">        String type = response.getHeaderValue(&quot;Content-Type&quot;);</span>
<span class="fc bfc" id="L286" title="All 4 branches covered.">        if (null != buff &amp;&amp; null != type) {</span>
<span class="fc" id="L287">            response.setSysEncoding(&quot;UTF-8&quot;);</span>
<span class="fc" id="L288">            String[] split = type.split(&quot;;&quot;);</span>
<span class="fc" id="L289">            response.setHttpContentType(FormatType.mapAcceptToFormat(split[0].trim()));</span>
<span class="fc bfc" id="L290" title="All 4 branches covered.">            if (split.length &gt; 1 &amp;&amp; split[1].contains(&quot;=&quot;)) {</span>
<span class="fc" id="L291">                String[] codings = split[1].split(&quot;=&quot;);</span>
<span class="fc" id="L292">                response.setSysEncoding(codings[1].trim().toUpperCase());</span>
            }
        }
<span class="fc" id="L295">        response.setHttpContent(buff, response.getSysEncoding(), response.getHttpContentType());</span>
<span class="fc" id="L296">    }</span>

    private byte[] readContent(InputStream content) throws IOException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (content == null) {</span>
<span class="fc" id="L300">            return null;</span>
        }
<span class="fc" id="L302">        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L303">        byte[] buff = new byte[1024];</span>

        while (true) {
<span class="fc" id="L306">            final int read = content.read(buff);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            if (read == -1) {</span>
<span class="fc" id="L308">                break;</span>
            }
<span class="fc" id="L310">            outputStream.write(buff, 0, read);</span>
<span class="fc" id="L311">        }</span>

<span class="fc" id="L313">        return outputStream.toByteArray();</span>
    }

    /**
     * use HttpClientConfig.setIgnoreSSLCerts(true) instead
     */
    @Override
    public void ignoreSSLCertificate() {
<span class="fc" id="L321">        throw new IllegalStateException(&quot;use HttpClientConfig.setIgnoreSSLCerts(true) instead&quot;);</span>
    }

    /**
     * use HttpClientConfig.setIgnoreSSLCerts(false) instead
     */
    @Override
    public void restoreSSLCertificate() {
<span class="fc" id="L329">        throw new IllegalStateException(&quot;use HttpClientConfig.setIgnoreSSLCerts(false) instead&quot;);</span>
    }

    @Override
    public boolean isSingleton() {
<span class="fc" id="L334">        return false;</span>
    }

    @Override
    public void close() {
        // do nothing
<span class="fc" id="L340">    }</span>


    /**
     * use HttpClientConfig.setIgnoreSSLCerts(true/false) instead
     */
    @Deprecated
<span class="fc" id="L347">    public static final class HttpsCertIgnoreHelper {</span>
        /**
         * use HttpClientConfig.setIgnoreSSLCerts(false) instead
         */
        @Deprecated
        public static void restoreSSLCertificate() {
<span class="fc" id="L353">            X509TrustAll.ignoreSSLCerts = false;</span>
<span class="fc" id="L354">        }</span>

        /**
         * use HttpClientConfig.setIgnoreSSLCerts(true) instead
         */
        @Deprecated
        public static void ignoreSSLCertificate() {
<span class="fc" id="L361">            X509TrustAll.ignoreSSLCerts = true;</span>
<span class="fc" id="L362">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>